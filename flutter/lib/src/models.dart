/// Data models for Kizuna API
/// 
/// This file contains all the data models used by the Kizuna API.
/// The actual implementations will be generated by Flutter Rust Bridge.

library models;

/// Configuration for Kizuna initialization
class KizunaConfig {
  /// Device name
  final String? deviceName;
  
  /// User name
  final String? userName;
  
  /// Enable mDNS discovery
  final bool enableMdns;
  
  /// Enable UDP discovery
  final bool enableUdp;
  
  /// Enable Bluetooth discovery
  final bool enableBluetooth;
  
  /// Enable encryption
  final bool enableEncryption;
  
  /// Require authentication
  final bool requireAuthentication;
  
  /// Trust mode
  final String trustMode;
  
  /// Listen port
  final int? listenPort;
  
  /// Enable IPv6
  final bool enableIpv6;
  
  /// Enable QUIC protocol
  final bool enableQuic;
  
  /// Enable WebRTC protocol
  final bool enableWebrtc;
  
  /// Enable WebSocket protocol
  final bool enableWebsocket;
  
  KizunaConfig({
    this.deviceName,
    this.userName,
    this.enableMdns = true,
    this.enableUdp = true,
    this.enableBluetooth = false,
    this.enableEncryption = true,
    this.requireAuthentication = true,
    this.trustMode = 'manual',
    this.listenPort,
    this.enableIpv6 = true,
    this.enableQuic = true,
    this.enableWebrtc = true,
    this.enableWebsocket = true,
  });
}

/// Information about a discovered peer
class PeerInfo {
  /// Peer ID
  final String id;
  
  /// Peer name
  final String name;
  
  /// Peer addresses
  final List<String> addresses;
  
  /// Peer capabilities
  final List<String> capabilities;
  
  /// Discovery method
  final String discoveryMethod;
  
  PeerInfo({
    required this.id,
    required this.name,
    required this.addresses,
    required this.capabilities,
    required this.discoveryMethod,
  });
}

/// Handle to a peer connection
class PeerConnection {
  /// Peer ID
  final String peerId;
  
  PeerConnection({required this.peerId});
}

/// Handle to a file transfer operation
class TransferHandle {
  /// Transfer ID
  final String transferId;
  
  TransferHandle({required this.transferId});
  
  /// Cancels the transfer
  Future<void> cancel() async {
    throw UnimplementedError('This will be implemented by Flutter Rust Bridge');
  }
}

/// Configuration for media streaming
class StreamConfig {
  /// Stream type ("camera", "screen", or "audio")
  final String streamType;
  
  /// Target peer ID
  final String peerId;
  
  /// Video quality (0-100)
  final int quality;
  
  StreamConfig({
    required this.streamType,
    required this.peerId,
    this.quality = 80,
  });
}

/// Handle to a media stream
class StreamHandle {
  /// Stream ID
  final String streamId;
  
  StreamHandle({required this.streamId});
  
  /// Stops the stream
  Future<void> stop() async {
    throw UnimplementedError('This will be implemented by Flutter Rust Bridge');
  }
}

/// Result of a command execution
class CommandResult {
  /// Command that was executed
  final String command;
  
  /// Peer ID
  final String peerId;
  
  /// Exit code
  final int exitCode;
  
  /// Standard output
  final String stdout;
  
  /// Standard error
  final String stderr;
  
  CommandResult({
    required this.command,
    required this.peerId,
    required this.exitCode,
    required this.stdout,
    required this.stderr,
  });
}

/// Event emitted by Kizuna
class KizunaEvent {
  /// Event type
  final String eventType;
  
  /// Event data as JSON string
  final String data;
  
  KizunaEvent({
    required this.eventType,
    required this.data,
  });
}

/// Transfer progress information
class TransferProgress {
  /// Transfer ID
  final String transferId;
  
  /// Bytes transferred
  final int bytesTransferred;
  
  /// Total bytes
  final int totalBytes;
  
  /// Transfer speed in bytes per second
  final int speedBps;
  
  TransferProgress({
    required this.transferId,
    required this.bytesTransferred,
    required this.totalBytes,
    required this.speedBps,
  });
  
  /// Calculates the transfer percentage
  double get percentage {
    if (totalBytes == 0) return 0.0;
    return (bytesTransferred / totalBytes) * 100.0;
  }
}
